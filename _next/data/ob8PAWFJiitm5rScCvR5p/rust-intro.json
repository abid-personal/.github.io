{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var r=Object.create;var l=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var s=a=>l(a,\"__esModule\",{value:!0});var u=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),g=(a,e)=>{s(a);for(var i in e)l(a,i,{get:e[i],enumerable:!0})},f=(a,e,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of h(e))!p.call(a,c)&&c!==\"default\"&&l(a,c,{get:()=>e[c],enumerable:!(i=d(e,c))||i.enumerable});return a},N=a=>f(s(l(a!=null?r(m(a)):{},\"default\",a&&a.__esModule&&\"default\"in a?{get:()=>a.default,enumerable:!0}:{value:a,enumerable:!0})),a);var t=u((k,o)=>{o.exports=_jsx_runtime});var v={};g(v,{default:()=>y,frontmatter:()=>w});var n=N(t()),w={title:\"A brief introduction to Rust\",date:\"2019-10-10\",tags:[\"Rust\",\"Programming\"],draft:!1,summary:\"A brief introduction to Rust\",images:[],layout:\"PostLayout\"};function b(a){let e=Object.assign({p:\"p\",hr:\"hr\",em:\"em\",code:\"code\",a:\"a\",pre:\"pre\",span:\"span\",blockquote:\"blockquote\",ul:\"ul\",li:\"li\",img:\"img\",strong:\"strong\"},a.components),{wrapper:i}=e,c=(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"This blog post will take a deep dive into the Rust world of mutability. By deep dive, it means the blog post is considerably long. So it will take time to go through the different examples. The topic we will dive through is specific but we will have to go through various Rust concepts: Ownership/Borrowing, Lifetimes, Unsafe, Sync, Closures, Macros and more. This might be intimidating and I think this is where many developers are put off.\"}),`\n`,(0,n.jsx)(e.p,{children:'This article assumes some familiarity with Rust; that is if you have successfully run a \"Hello World\" program, then you are qualified! If you have struggled with some of the hard concepts then this article could be a good introduction. It will not go deep for each one of these but will give you enough knowledge to help you understand the bigger picture.'}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.p,{children:[\"We will start from a \",(0,n.jsx)(e.em,{children:\"reasonably\"}),\" easy problem: We want to access a particular variable from any location in our program; by access, I mean both read and write access. That might seem like a straightforward thing to do, especially if you are coming from other languages like JavaScript. If we have a variable (and the browser is our sandbox), then we can make it global by attaching it to the \",(0,n.jsx)(e.code,{children:\"window\"}),\" object. So if we have \",(0,n.jsx)(e.code,{children:\"window.config\"}),\", we can access (both read and write) the \",(0,n.jsx)(e.code,{children:\"config\"}),\" variable from anywhere in our code.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"So our problem is we have this \",(0,n.jsx)(e.code,{children:\"config\"}),\" object but in Rust. The configuration object is a \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/rust-by-example/custom_types/structs.html\",children:\"struct\"}),\". It can be set and initialized somewhere in our program. The initialization bit is important as we will find out later. Our configuration could be simple default values set in the code, and updated later; or it could require reading files, exchanging data over the network, etc. So we want to be sure that we can do both.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We have other requirements and although most of the use cases don't need these niceties, it is better to have them for the future (And these are the kind of problems that Rust is intended to solve). Like, for example, our program might also become multithreaded in the future, as we anticipate more cores in the CPU and less improvement in the clock rate.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Things are already starting to confuse; so how about we start with a simple example and the most basic implementation of a configuration struct.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Hello, world!\");\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Debugging value: {}\", config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Rechecking Debugging value: {}\", config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn config() -> MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig { debug: false }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`Hello, world!\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Debugging value: false\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Rechecking Debugging value: false\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Pretty simple: We use a function named \",(0,n.jsx)(e.code,{children:\"config\"}),\" to return an instance of our configuration. Inside \",(0,n.jsx)(e.code,{children:\"config\"}),\", we make a new \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\" instance for each call and then return it. (We could have placed this code in a different file and called it with \",(0,n.jsx)(e.code,{children:\"mod filename\"}),\"; we are going to do that later, so don't worry!).\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"So far so good. But there is a small issue here: Every time we call the \",(0,n.jsx)(e.code,{children:\"config\"}),\" function, we return a \",(0,n.jsx)(e.em,{children:\"new\"}),\" instance of \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\". Practically speaking, it is the \",(0,n.jsx)(e.em,{children:\"same\"}),\" configuration; but technically speaking, it is a \",(0,n.jsx)(e.em,{children:\"different\"}),\" object. Imagine, for instance, that our \",(0,n.jsx)(e.code,{children:\"config\"}),\" function was querying a database for a particular field. The \",(0,n.jsx)(e.code,{children:\"config\"}),\" function will be doing the query every time we call it. This is not good; after all we should only do it one time both for efficiency and consistency.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"What we want is a single initialization of our configuration. That initialization is safeguarded somewhere, and then we access it as many times as we want. Basically, a global variable accessible from the \",(0,n.jsx)(e.code,{children:\"config\"}),\" function or any other location in our program.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This time, we will separate our program into two files: \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\" and \",(0,n.jsx)(e.code,{children:\"config.rs\"}),\". The code could function from within \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\" but the separation of concerns is helpful.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Hello, world!\");\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Debug: {}\", MyConfig::global_config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Rechecking Debug: {}\", MyConfig::global_config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`static CONFIG: MyConfig = MyConfig { debug: false };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config() -> &'static MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        &CONFIG\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Alright, a lot is going on here; especially if you are both new to and confused by the Rust syntax. But don't worry, we will explain it in details. First, we are still using a function to return our configuration; but this time it is attached to the \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\" struct. Think of a Rust struct like a JavaScript object or in OOP languages like a class where you can add both fields and methods to your struct. The method that returns our configuration is \",(0,n.jsx)(e.code,{children:\"global_config\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's go back further, this line deserves some explanation.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"code-highlight\",children:(0,n.jsx)(e.span,{className:\"code-line\",children:`static CONFIG: MyConfig = MyConfig { debug: false };\n`})})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Creating a \",(0,n.jsx)(e.em,{children:\"global variable\"}),\" in Rust is pretty easy. We just use the \",(0,n.jsx)(e.code,{children:\"static\"}),\" keyword. Now, our variable \",(0,n.jsx)(e.em,{children:\"can be\"}),\" available anywhere in our program. In fact, this is what the rust-lang documentation says about the \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html\",children:\"static\"}),\" keyword:\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"A 'static lifetime is the longest possible lifetime, and lasts for the lifetime of the running program.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Okay, that was a trap. What is a \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/rust-by-example/scope/lifetime.html\",children:\"lifetime\"}),\"? Well, you can go with the raw and naive definition: How long you will live. But that definition doesn't seem about our \",(0,n.jsx)(e.code,{children:\"static\"}),\" keyword, or is it? It is also way too simplistic. The rust-lang website will already throw words like \",(0,n.jsx)(e.em,{children:\"borrow checker\"}),\" at you. That's scary, so how about we stick to the raw definition for now: How long the variable will live.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"So what's \",(0,n.jsx)(e.code,{children:\"'static\"}),\"? It is the longest lifetime; which means the entirety of our program. It means our variable will be \",(0,n.jsx)(e.em,{children:\"alive\"}),\" and accessible as long as our program is running. The \",(0,n.jsx)(e.code,{children:\"static\"}),\" keyword doesn't mean our variable is a \",(0,n.jsx)(e.em,{children:\"constant\"}),\" but just that it has a \",(0,n.jsx)(e.code,{children:\"'static\"}),\" lifetime. A better word is \",(0,n.jsx)(e.em,{children:\"immortal\"}),\" but that doesn't sound geeky and cryptic enough and hence the choice of \",(0,n.jsx)(e.code,{children:\"'static\"}),\". If you are still confused, notice that \",(0,n.jsx)(e.code,{children:\"'static\"}),\" is the name of the lifetime while \",(0,n.jsx)(e.code,{children:\"static\"}),\" is a keyword that gives our variable a \",(0,n.jsx)(e.code,{children:\"'static\"}),\" lifetime.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Our configuration is initialized once and we declare a global variable named \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\". To access it, we use the function \",(0,n.jsx)(e.code,{children:\"global_config\"}),\" implemented in our struct; but since it is a global variable we could access it from anywhere really.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's dissect the \",(0,n.jsx)(e.code,{children:\"global_config\"}),\" function. If you are new to Rust, you might have already noticed the gibberish in that function. We are not returning \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\" in the function signature but adding a bunch of keywords; something must be going on.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"To understand what is going on, you might need to understand the Rust Ownership/Borrowing model. Don't worry, we will stick to the naive definition: You can't take/move what you don't own, but you can borrow it. You can't make changes on what you borrow unless you request permissions; and even then you are going to have to follow some rules.\"}),`\n`,(0,n.jsx)(e.p,{children:\"So let's test the constitution. If you run this line inside the main function.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"code-highlight\",children:(0,n.jsx)(e.span,{className:\"code-line\",children:`let myconfig: MyConfig = config::CONFIG;\n`})})}),`\n`,(0,n.jsx)(e.p,{children:\"On execution, we are going to get the following error.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`error[E0507]: cannot move out of static item\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` --> src/main.rs:9:30\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`9 |     let myconfig: MyConfig = config::CONFIG;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |                              ^^^^^^^^^^^^^^\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |                              |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |                              cannot move out of static item\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"  |                              help: consider borrowing here: `&config::CONFIG`\\n\"})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We do not own \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\". The ruler, therefore, would not allow moving it but most importantly: There is no way around it. The ruler would also gives us a hint: consider borrowing.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Borrowing is actually pretty cool: We can access the object from where it is located; and that is basically it. But that serves our purposes, right? (Plus Rust doesn't charge us any interest!).\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"So this code is fine. (again we can run this code on \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\")\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`  let myconfig: &MyConfig = &config::CONFIG;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  dbg!(myconfig.debug);\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Notice that here we do neither own nor move \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\". We are barely \",(0,n.jsx)(e.em,{children:\"referencing\"}),\" it. The type of my \",(0,n.jsx)(e.code,{children:\"myconfig\"}),\" is \",(0,n.jsx)(e.code,{children:\"&MyConfig\"}),\" and not \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\". A reference, and not the actual thing. To create a reference, we use an ampersand \",(0,n.jsx)(e.code,{children:\"&\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you have been successfully following along, you almost did understand what the code in \",(0,n.jsx)(e.code,{children:\"global_config\"}),\" does. Except for one more sketchy keyword: \",(0,n.jsx)(e.code,{children:\"&'static\"}),\". If we tried to return \",(0,n.jsx)(e.code,{children:\"&MyConfig\"}),\" instead of \",(0,n.jsx)(e.code,{children:\"&'static MyConfig\"}),\", we will get the following error.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`error[E0106]: missing lifetime specifier\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` --> src/config.rs:9:31\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`9 |     pub fn global_config() -> &MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"  |                               ^ help: consider giving it a 'static lifetime: `&'static`\\n\"}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"The ruler is asking for a lifetime to our reference. You might be wondering: Why, and what does that mean? And what does a reference mean in the first place?\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\",children:\"Rust Programming Language book\"}),\" has a rather helpful definition.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"These ampersands are references, and they allow you to refer to some value without taking ownership of it.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"The opposite of referencing by using & is dereferencing, which is accomplished with the dereference operator, *.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Okay, so referencing is actually \",(0,n.jsx)(e.em,{children:\"borrowing\"}),\". But what is a lifetime? \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/rust-by-example/scope/lifetime.html\",children:\"Rust By Example\"}),\" has an average explanation.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"A lifetime is a construct the compiler (or more specifically, its borrow checker) uses to ensure all borrows are valid. Specifically, a variable's lifetime begins when it is created and ends when it is destroyed. While lifetimes and scopes are often referred to together, they are not the same.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Take, for example, the case where we borrow a variable via &. The borrow has a lifetime that is determined by where it is declared. As a result, the borrow is valid as long as it ends before the lender is destroyed. However, the scope of the borrow is determined by where the reference is used.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"What if \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\" is dropped from memory? Now, we know for certain that this will not happen because \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\" is \",(0,n.jsx)(e.em,{children:\"immortal\"}),\" but the compiler doesn't know that. In our signature, we are returning a reference to \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\" and not \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\"; so it is not clear how long the real object will live for. If that object is dropped, then our reference will fail. We need to ensure that our reference lives at most as the object it is \",(0,n.jsx)(e.em,{children:\"pointing\"}),\" at. Not more.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In my opinion, the hard part about lifetimes is the unreadable gibberish that accompanies it. First, we need to define (or name) a lifetime. We do that before the function signature. We will make use of \",(0,n.jsx)(e.code,{children:\"<,>\"}),` and an apostrophe; that's pretty clean. To make it more confusing, let's name our lifetime \"a\" even though we can use a more meaningful names. If everybody on the community does that, it will greatly help beginners: They will think it is some sort of keyword out there. But as we will use it again in the returned value with an apostrophe, they will finally succumb and concede that it is pure wizardry.`]}),`\n`,(0,n.jsx)(e.p,{children:\"Look at this! This code actually runs!\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:` pub fn global_config<'a>() -> &'a MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let myconfig = MyConfig { debug: true };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        &myconfig\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Instead of defining a lifetime, we can assign the \",(0,n.jsx)(e.code,{children:\"'static\"}),\" lifetime. That makes sense since the item we are borrowing from has a \",(0,n.jsx)(e.code,{children:\"'static\"}),\" lifetime itself and should live for the entirety of the program. We don't need to define the \",(0,n.jsx)(e.code,{children:\"'static\"}),\" lifetime though, as it already is. If we replace the \",(0,n.jsx)(e.code,{children:\"'a\"}),\" with \",(0,n.jsx)(e.code,{children:\"'static\"}),\" and remove the definition, we will achieve our previous program.\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's move ahead. Now that your business is growing, your configuration is getting more sophisticated. In order to initialize the configuration, you need to run some tasks (like querying a database or reading from a file). Basically, you want to call a function that returns your configuration instead of having it \",(0,n.jsx)(e.em,{children:\"statically\"}),\" defined.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub static CONFIG: MyConfig = MyConfig::new();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn new() -> Self {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        MyConfig { debug: false }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config() -> &'static MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        &CONFIG\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This new code defines a function \",(0,n.jsx)(e.code,{children:\"new\"}),\"; which you might think of as a constructor. It will create a new instance of \",(0,n.jsx)(e.code,{children:\"Myconfig\"}),\" and returns it. Since it is implemented within the \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\" struct, it is basically returning an instance of itself. Thus, the use of the keyword \",(0,n.jsx)(e.code,{children:\"self\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Unluckily, this doesn't work. The ruler, again, complains.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:` --> src/config.rs:6:31\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`6 | pub static CONFIG: MyConfig = MyConfig::new();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |                               ^^^^^^^^^^^^^^^\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In case you think this is restricting, you need to understand one more idea: Statics are evaluated at compile time; in other words they are \",(0,n.jsx)(e.em,{children:\"hard-coded\"}),\" into the binary. Functions, on the other hand, are only called at run time. This means Rust can't determine the value of our static variable at compile time; and therefore can't compile the program.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is a major roadblock and there seems to be no way around it. Since it is impossible to assign a value to a \",(0,n.jsx)(e.em,{children:\"non-mutable\"}),\" static variable at run time, we will have to resort to magic. If you are a scientist and don't believe in magic, then this is a good time.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"First, we need to add an external dependency named \",(0,n.jsx)(e.code,{children:\"lazy_static\"}),\" to the \",(0,n.jsx)(e.code,{children:\"Cargo.toml\"}),\" file.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"Cargo.toml\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`[dependencies]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`lazy_static = \"1.3.0\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Next, we import the dependency on \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[macro_use]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`extern crate lazy_static;\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"And now to the magical part, replace the previous definition with the following.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`lazy_static! {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub static ref CONFIG: MyConfig = MyConfig::new();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Tada! Now our program works. Pretty cool, heh? It is not clear what kind of magic the \",(0,n.jsx)(e.code,{children:\"lazy_static\"}),\" did but it just works. So that was lucky!\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.p,{children:[\"Except things are about to complicate a bit more. A new bureaucrat in the organization demands that he is able to pass the debug value to the configuration constructor. Bureaucrats want control and this particular one is not happy that debug can only be set from within the \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\" constructor since it is outside of his jurisdiction.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"So we change our constructor to allow him to sneak in.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`pub fn new(custom_debug: Option<bool>) -> Self {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // We are just eluding him of power, we don't actually use the custom_debug variable.\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        MyConfig { debug: false }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This code is fine but it won't compile because the static variable will require that we pass an optional boolean value. In case you don't know what \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/option/index.html\",children:\"Option\"}),\"s are, this is a good time to introduce them. The bureaucrat is not certain that he wants to pass a debug value all the times. He just wants to have the option in case he feels like it. Rust, however, requires that parameters (declared in the function signature) are fully respected. That is, if we have a debug parameter, it needs to be there.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To manage this bureaucracy, Rust introduces an \",(0,n.jsx)(e.code,{children:\"Option\"}),\" type: It encapsulates the real value if there is one; and if there is none it returns a type named \",(0,n.jsx)(e.code,{children:\"None\"}),\". Simple. It also has a set of functions to manage that additional bureaucracy overhead.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"To make our code compile, we can do the following.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`lazy_static! {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub static ref CONFIG: MyConfig = MyConfig::new(Some(false));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Notice that we are using a function named \",(0,n.jsx)(e.code,{children:\"Some\"}),\". This is because the value that we need to pass is not a \",(0,n.jsx)(e.code,{children:\"bool\"}),\" but an \",(0,n.jsx)(e.code,{children:\"Option<bool>\"}),\". The \",(0,n.jsx)(e.code,{children:\"Some\"}),\" function encapsulates our \",(0,n.jsx)(e.code,{children:\"bool\"}),\" inside an \",(0,n.jsx)(e.code,{children:\"Option\"}),\". So that was easy.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Except that bureaucrats can't access the \",(0,n.jsx)(e.code,{children:\"config.rs\"}),\" file. They need to pass the value from another place: \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\". Since our \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\" is not defined there, we need to create a new function to accommodate. This is going to complicate our setup but we have to comply.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Easy, right?\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`pub fn init(custom_debug: Option<bool>) -> Result<(), i32> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        lazy_static! {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            pub static ref CONFIG: MyConfig = MyConfig::new(Some(false));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Ok(())\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here we introduce, again, a new type: \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/result/\",children:\"Result\"}),\". \",(0,n.jsx)(e.code,{children:\"Result\"}),\" is similar to \",(0,n.jsx)(e.code,{children:\"Option\"}),\" but serves another purpose and the name should be self-explanatory. \",(0,n.jsx)(e.code,{children:\"Result\"}),\" could be either a success and return our result (in this case \",(0,n.jsx)(e.code,{children:\"()\"}),\") or a failure and return an error (in this case \",(0,n.jsx)(e.code,{children:\"i32\"}),\"). I'm not going to go through it but you can check the \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/result/\",children:\"Rust docs\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Unfortunately, this doesn't work. Even though \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\" has a static (infinite) lifetime, you can't access it outside the \",(0,n.jsx)(e.code,{children:\"init\"}),\" function. In order to be able to do that, you need to return it. But we don't want to do that; and neither that works (We do not own \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\").\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you think things started to overly complicate; then hold your breath. In the last example, we were not passing the \",(0,n.jsx)(e.code,{children:\"custom_debug\"}),\" variable; we were just accepting it in the function signature. Now that our bureaucrats found out our misdeed, we need to pass it to the \",(0,n.jsx)(e.code,{children:\"lazy_static!\"}),\" block; but if we do, we get the following error.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`error[E0434]: can't capture dynamic environment in a fn item\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  --> src/config.rs:12:61\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`   |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`12 |             pub static ref CONFIG: MyConfig = MyConfig::new(custom_debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`   |                                                             ^^^^^^^^^^^^\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`   |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"   = help: use the `|| { ... }` closure form instead\\n\"})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Great, things are getting out of control; and Rust is throwing an unreadable error message. What is an \",(0,n.jsx)(e.em,{children:\"fn item\"}),\", a \",(0,n.jsx)(e.em,{children:\"dynamic environment\"}),\" and a \",(0,n.jsx)(e.em,{children:\"closure\"}),\"? That's a lot to take on a single error message and we already have another part of our program non-functioning. The truth is, we are coming to the reality that \",(0,n.jsx)(e.code,{children:\"lazy_static!\"}),\" is not magic. It is just a macro.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"What is a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Macro_(computer_science)\",children:\"macro\"}),\"?\"]}),`\n`,(0,n.jsx)(e.p,{children:\"A macro is a way to generate Rust code for you. But what is this macro exactly generating? That could shed some light to what it does and maybe hint to better solutions.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Well, it turns out that it is possible to know that. Using this command, we can output the final code that Rust is compiling.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"code-highlight\",children:(0,n.jsx)(e.span,{className:\"code-line\",children:`cargo rustc -- -Z unstable-options --pretty=expanded\n`})})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you run this, you will see that a lot is going on. \",(0,n.jsx)(e.code,{children:\"println!\"}),\" is a macro. That means the final code is much more than that single line. For now, we will focus on the code generated by \",(0,n.jsx)(e.code,{children:\"lazy_static!\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`            #[allow(missing_copy_implementations)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            #[allow(non_camel_case_types)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            #[allow(dead_code)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            pub struct CONFIG {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                __private_field: (),\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            #[doc(hidden)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            pub static CONFIG: CONFIG = CONFIG{__private_field: (),};\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            impl ::lazy_static::__Deref for CONFIG {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                type\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                Target\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                =\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                fn deref(&self) -> &MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                    #[inline(always)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                    fn __static_ref_initialize() -> MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                        MyConfig::new(custom_debug)\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                    #[inline(always)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                    fn __stability() -> &'static MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                        static LAZY: ::lazy_static::lazy::Lazy<MyConfig> =\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                            ::lazy_static::lazy::Lazy::INIT;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                        LAZY.get(__static_ref_initialize)\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                    __stability()\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            impl ::lazy_static::LazyStatic for CONFIG {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                fn initialize(lazy: &Self) { let _ = &**lazy; }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            }\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"Oops...\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"There is a lot going on here. First, \",(0,n.jsx)(e.code,{children:\"lazy_static!\"}),\" is creating a new type (\",(0,n.jsx)(e.code,{children:\"config::MyConfig::init::CONFIG\"}),\"). This can explain this weird error message when we try to return \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`error[E0308]: mismatched types\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  --> src/config.rs:15:12\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`   |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`15 |         Ok(CONFIG)\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"   |            ^^^^^^ expected struct `config::MyConfig`, found struct `config::MyConfig::init::CONFIG`\\n\"}),(0,n.jsx)(e.span,{className:\"code-line\",children:`   |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"   = note: expected type `config::MyConfig`\\n\"}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"              found type `config::MyConfig::init::CONFIG`\\n\"})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Cool. We are no longer using the \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\" struct but another one that \",(0,n.jsx)(e.code,{children:\"lazy_static!\"}),\" invented. It looks like \",(0,n.jsx)(e.code,{children:\"lazy_static!\"}),\" has code that executes our function, gets the returned value and creates a new type that imitates our struct. But don't take my word for it. I just happen to know about Rust as much as you do!\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.p,{children:[\"Remind me again: \",(0,n.jsx)(e.em,{children:\"Why are we here\"}),\"?\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The thing is, our problem seems to be simple. Only if we were able to change the value of the static variable after declaring it. That will solve all of our headaches. Let us get rid of \",(0,n.jsx)(e.code,{children:\"lazy_static!\"}),\" and possibly enjoy the rest of the day with friends.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Who said we can't?\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Hello, world!\");\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Debug value: {}\", MyConfig::global_config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(true));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Recheck Debug value: {}\", MyConfig::global_config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub static mut CONFIG: MyConfig = MyConfig { debug: false };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn init(custom_debug: Option<bool>) -> Result<(), i32> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        unsafe {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            CONFIG.debug = custom_debug.unwrap_or(false);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Ok(())\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config() -> &'static MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        unsafe { &CONFIG }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`Hello, world!\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Debug value: false\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Recheck Debug value: true\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Notice a few things here: \",(0,n.jsx)(e.code,{children:\"static\"}),\" means a \",(0,n.jsx)(e.code,{children:\"'static\"}),\" (infinite) lifetime. It doesn't mean we can't mutate the variable. It is not a constant. We can change it if we add the keyword \",(0,n.jsx)(e.code,{children:\"mut\"}),\". Rust doesn't consider it safe (Thus the \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\",children:\"unsafe\"}),\" keyword) but what does Rust know about the life of the streets??! Our program works. There is \",(0,n.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=RS7IzU2VJIQ\",children:\"plastic in the ocean\"}),\"; I mean, on the big scheme of things, this is a minor issue, right?\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.p,{children:\"But this is not what Rust stands for, is it? We need to live up to the hype, but how do we go about that?\"}),`\n`,(0,n.jsx)(e.p,{children:\"We can start by putting this line at the top of our program.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"code-highlight\",children:(0,n.jsx)(e.span,{className:\"code-line\",children:`#![forbid(unsafe_code)]\n`})})}),`\n`,(0,n.jsx)(e.p,{children:\"Running the previous code will now result in an error.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:\"error: usage of an `unsafe` block\\n\"}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  --> src/config.rs:10:9\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`   |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`10 | /         unsafe {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`11 | |             CONFIG.debug = custom_debug.unwrap_or(false);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`12 | |         }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`   | |_________^\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`   |\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"Now we know what we want. We want a global variable that we can, at a certain point, mutate with external variables. But we must do that safely; and be ready for the future of multiple processors, cores and threads.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Let's start with the global variable mutation. One might think that it is not possible to safely mutate static variables. And that's actually correct which is why the Rust team has come up with some solutions.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Hidden somewhere in one of Rust's types documentation (\",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/cell/struct.Cell.html\",children:\"Cell\"}),\"), we can read the following.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Rust memory safety is based on this rule: Given an object T, it is only possible to have one of the following:\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Having several immutable references (&T) to the object (also known as aliasing).\"}),`\n`,(0,n.jsx)(e.li,{children:\"Having one mutable reference (&mut T) to the object (also known as mutability).\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Yes, that's our problem right here.\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"This is enforced by the Rust compiler. However, there are situations where this rule is not flexible enough. Sometimes it is required to have multiple references to an object and yet mutate it.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Shareable mutable containers exist to permit mutability in a controlled manner, even in the presence of aliasing. bla bla bla...\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Cool. That's our solution right there. The \",(0,n.jsx)(e.code,{children:\"Cell\"}),\"! Let's go and implement it.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(MyConfig::global_config());\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::cell::Cell;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug, Copy, Clone)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub static CONFIG: Cell<MyConfig> = Cell::new(MyConfig { debug: false });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn init(custom_debug: Option<bool>) -> Result<(), i32> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        match custom_debug {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            Some(debug_value) => CONFIG.set(MyConfig { debug: debug_value }),\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            None => (),\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Ok(())\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config() -> MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        CONFIG.get()\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:\"error[E0277]: `std::cell::Cell<config::MyConfig>` cannot be shared between threads safely\\n\"}),(0,n.jsx)(e.span,{className:\"code-line\",children:` --> src/config.rs:8:1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`8 | pub static CONFIG: Cell<MyConfig> = Cell::new(MyConfig { debug: false });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `std::cell::Cell<config::MyConfig>` cannot be shared between threads safely\\n\"}),(0,n.jsx)(e.span,{className:\"code-line\",children:`  |\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"  = help: the trait `std::marker::Sync` is not implemented for `std::cell::Cell<config::MyConfig>`\\n\"}),(0,n.jsx)(e.span,{className:\"code-line\",children:\"  = note: shared static variables must have a type that implements `Sync`\\n\"})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This doesn't work but it is important to note that this particular configuration, add a few complications: The \",(0,n.jsx)(e.code,{children:\"Clone\"}),\" and \",(0,n.jsx)(e.code,{children:\"Copy\"}),\" keywords. While they seem harmless now, they might be limiting for your future configurations complexity. In case you are wondering what they are about, we will get to them later on in this article.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"But, for now, the gist of it, is that \",(0,n.jsx)(e.code,{children:\"Cell\"}),\" is not thread-safe; whatever that means. We need a type like \",(0,n.jsx)(e.code,{children:\"Cell\"}),\" but that happens to be \",(0,n.jsx)(e.em,{children:\"thread-safe\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Browsing more through the Rust website, we find the \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/atomic/\",children:\"atomic types\"}),\".\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Reading further into the documentation.\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Atomic variables are safe to share between threads (they implement Sync) but they do not themselves provide the mechanism for sharing and follow the threading model of rust. The most common way to share an atomic variable is to put it into an Arc (an atomically-reference-counted shared pointer).\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Atomic variables looks like they are the building block for higher-level types that might solve our problem. We should not use them (as per the advice of the documentation) and instead use the higher-level abstractions.\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Most of the low-level synchronization primitives are quite error-prone and inconvenient to use, which is why the standard library also exposes some higher-level synchronization objects.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"These objects are \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/struct.Arc.html\",children:\"Arc\"}),\", \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/struct.Barrier.html\",children:\"Barrier\"}),\", \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/struct.Condvar.html\",children:\"Condvar\"}),\", \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/struct.Mutex.html\",children:\"Mutex\"}),\", \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/struct.Once.html\",children:\"Once\"}),\", and \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/struct.RwLock.html\",children:\"RwLock\"}),\". That's a lot and might mean that the problem at hand is rather hard. Imagine you have two threads executing at the same time: You'd want a solid framework to let them share access to the same variable. That's basically what this mess is about. If we were to have a single-threaded application, things would be much simpler. But we live in a world where quantum tunneling is a real thing!\"]}),`\n`,(0,n.jsx)(e.p,{children:\"So which one do we need? We want multiple access to the global variable (configuration). There are several that can fit the bill. Each has its own quirks and limitations.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's look for example at \",(0,n.jsx)(e.code,{children:\"Once\"}),\".\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the ONCE_INIT value or the equivalent Once::new constructor.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"This sounds good if we want to do a single, one-time initialization of our configuration variable. But how is the code going to look like and what if we initialize twice?\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Hello, world!\");\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Debug value: {}\", MyConfig::global_config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(true));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Recheck Debug value: {}\", MyConfig::global_config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(false));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Recheck Debug value: {}\", MyConfig::global_config().debug);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::sync::Once;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub static INIT: Once = Once::new();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub static mut CONFIG: MyConfig = MyConfig { debug: false };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn init(custom_debug: Option<bool>) -> Result<(), i32> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        INIT.call_once(|| unsafe {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            match custom_debug {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                Some(debug_value) => CONFIG = MyConfig { debug: true },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                None => (),\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Ok(())\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config() -> &'static MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        unsafe { &CONFIG }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"The program runs and here is the output.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`Hello, world!\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Debug value: false\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Recheck Debug value: true\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Recheck Debug value: true\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Cool. The \",(0,n.jsx)(e.code,{children:\"init\"}),\" function is functioning as expected. If we recall \",(0,n.jsx)(e.code,{children:\"init\"}),\" twice, however, nothing happens. We can pass variables to our closure. So everything is working just fine. Plus we got rid of the \",(0,n.jsx)(e.code,{children:\"lazy_static\"}),\" crate. One thing to keep out of this mess.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Except, if you have a good eye, you should have noticed something that you probably won't like much (at least if you agreed with our previous monologue). We are using \",(0,n.jsx)(e.code,{children:\"unsafe\"}),\" code!\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Well, according to Rust, this should be pretty safe.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:\"// Accessing a `static mut` is unsafe much of the time, but if we do so\\n\"}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// in a synchronized fashion (e.g., write once or read all) then we're\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`// good to go!\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"But there is still something bugging me about it: First, we can only change the configuration one time. This might be enough but it is not quite what we want. Second, we are using \",(0,n.jsx)(e.code,{children:\"unsafe\"}),\" blocks of code. While this is somewhat safe, it opens up the possibility that a developer handles the code unsafely. After all, you just opened a can of worms in a controlled environment. That might have risks since the environment might get out of our control as the code base grows and more developers are recruited.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Better keep the can of worms closed if we can afford it. Luckily, we have a wide range of sync objects to choose from. Let's look at \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\".\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"This type of lock allows a number of readers or at most one writer at any point in time. The write portion of this lock typically allows modification of the underlying data (exclusive access) and the read portion of this lock typically allows for read-only access (shared access).\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Sounds too good to be true? This allows us, basically, to modify the global variables (from a single location) and access it from multiple locations. Well it does come with some complications, however.\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"The type parameter T represents the data that this lock protects. It is required that T satisfies Send to be shared across threads and Sync to allow concurrent access through readers. The RAII guards returned from the locking methods implement Deref (and DerefMut for the write methods) to allow access to the content of the lock.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"That's some more gibberish out there; but this looks like something we should be able to manage. Let's give it a try.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[macro_use]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`extern crate lazy_static;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(true));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(false));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::sync::RwLock;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`lazy_static! {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub static ref CONFIG: RwLock<MyConfig> = RwLock::new(MyConfig { debug: false });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn init(custom_debug: Option<bool>) -> Result<(), i32> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let mut w = CONFIG.write().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        match custom_debug {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            Some(debug_value) => *w = MyConfig { debug: debug_value },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            None => (),\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Ok(())\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config()\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let m = CONFIG.read().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        dbg!(m);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This program requires \",(0,n.jsx)(e.code,{children:\"lazy_static\"}),\" as a dependency. If we \",(0,n.jsx)(e.code,{children:\"cargo run\"}),\" it, we will get the following output.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/config.rs:26] m = RwLockReadGuard {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    lock: RwLock {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        data: MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            debug: false,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/config.rs:26] m = RwLockReadGuard {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    lock: RwLock {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        data: MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            debug: true,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/config.rs:26] m = RwLockReadGuard {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    lock: RwLock {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        data: MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            debug: false,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Looks good? We have a static global variable \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\". Inside this global variable is a \",(0,n.jsx)(e.code,{children:\"RwLock<MyConfig>\"}),\" object. We can mutate the inside of the \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\" by using the \",(0,n.jsx)(e.code,{children:\"write\"}),\" function. We do this in the \",(0,n.jsx)(e.code,{children:\"init\"}),\" function of \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\"; and we can also pass variables.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"So everything is good, right? Well, kind of. You might have noticed that we are not returning the \",(0,n.jsx)(e.code,{children:\"CONFIG\"}),\" struct or a reference to it. Instead, we are displaying the content inside the function itself. But that might not be what you want, you might want to access the values from another place and access it directly.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can try that but let's first understand what \",(0,n.jsx)(e.code,{children:\"CONFIG.read().unwrap()\"}),\" is returning. Using the \",(0,n.jsx)(e.code,{children:\"dbg!\"}),\" command, we are getting the following.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/config.rs:26] m = RwLockReadGuard {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    lock: RwLock {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        data: MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            debug: false,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"So it is not our \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\". Or, it is our \",(0,n.jsx)(e.code,{children:\"MyConfig\"}),\" but wrapped inside another structure of the type \",(0,n.jsx)(e.code,{children:\"RwLockReadGuard\"}),\" and stored two levels deep (\",(0,n.jsx)(e.code,{children:\"lock\"}),\" and \",(0,n.jsx)(e.code,{children:\"data\"}),\" fields). The documentation for it is the following.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"RAII structure used to release the shared read access of a lock when dropped.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"This structure is created by the read and try_read methods on RwLock.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"That's more gibberish. What is \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization\",children:\"RAII\"}),\"?\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Resource acquisition is initialization (RAII)[1] is a programming idiom[2] used in several object-oriented languages to describe a particular language behavior. In RAII, holding a resource is a class invariant, and is tied to object lifetime: resource allocation (or acquisition) is done during object creation (specifically initialization), by the constructor, while resource deallocation (release) is done during object destruction (specifically finalization), by the destructor.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"There is another \",(0,n.jsx)(e.a,{href:\"https://www.toptal.com/software/eliminating-garbage-collector\",children:\"article\"}),\" that has another definition.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"All that manual management was unpleasant, to say the least. In the mid-80s, Bjarne Stroustrup invented a new paradigm for his brand-new language, C++. He called it Resource Acquisition Is Initialization, and the fundamental insights were the following: objects can be specified to have constructors and destructors which are called automatically at appropriate times by the compiler, this provides a much more convenient way to manage the memory a given object requires, and the technique is also useful for resources which are not memory.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"So that's good. But isn't everything in Rust a RAII structure and what does it mean for our \",(0,n.jsx)(e.code,{children:\"RwLockReadGuard\"}),\"? To see how this unfolds, let's try returning our \",(0,n.jsx)(e.code,{children:\"RwLockReadGuard\"}),\". We will have to unlock every time we want to access the data but there is a price for everything, right?\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[macro_use]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`extern crate lazy_static;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Initialize the configuration\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(true));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Return 'RwLockReadGuard'\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let a = MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Display 'MyConfig'\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(&*a);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::sync::RwLock;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::sync::RwLockReadGuard;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`lazy_static! {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub static ref CONFIG: RwLock<MyConfig> = RwLock::new(MyConfig { debug: false });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn init(custom_debug: Option<bool>) -> Result<(), i32> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let mut w = CONFIG.write().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        match custom_debug {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            Some(debug_value) => *w = MyConfig { debug: debug_value },\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            None => (),\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Ok(())\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config() -> RwLockReadGuard<'static, MyConfig> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let m: RwLockReadGuard<'static, MyConfig> = CONFIG.read().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        m\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"Run the following and we will get.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/main.rs:15] &*a = MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    debug: true,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"So that's perfect, right? Let's try to re-initialize our configuration struct.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[macro_use]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`extern crate lazy_static;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Initialize the configuration\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(true));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Return 'RwLockReadGuard'\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let a = MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Display 'MyConfig'\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(&*a);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Reinit MyConfig\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(false));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Return 'RwLockReadGuard'\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let b = MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Display 'MyConfig'\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(&*b);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"Output\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/main.rs:15] &*a = MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    debug: true,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"Hmm, not exactly the output we expect. Wait! The program didn't quit. It is stuck there!\"}),`\n`,(0,n.jsx)(e.p,{children:\"We tried to cheat our way out of this complexity by plowing through the different types and trying different things. But, obviously, we hit another roadblock. It'd be better to get an understanding of why our program suddenly halted and never returned. It is like our program is stuck in an infinite loop but there is no loop in our code. Or is there?\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.p,{children:[\"Remind me again: \",(0,n.jsx)(e.em,{children:\"Why are we here\"}),\"?\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Why are we going through all of this complexity? What is exactly wrong with simple \",(0,n.jsx)(e.code,{children:\"unsafe\"}),\" code. Well, to understand that, you might need to witness the dangers of \",(0,n.jsx)(e.code,{children:\"unsafe\"}),\" code in real life.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"First, let's remember that our problem only exists if we are working on multiple threads. This means multiple cores. Let's look at this video from a Udacity online MOOC (\",(0,n.jsx)(e.a,{href:\"https://www.udacity.com/course/high-performance-computer-architecture--ud007\",children:\"High Performance Computer Architecture\"}),\"). I would recommend you take the whole course later as it goes deeper on other related topics; but for now this video will do it.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=BMkW9Iwh80E\",children:(0,n.jsx)(e.img,{src:\"http://img.youtube.com/vi/BMkW9Iwh80E/0.jpg\",alt:\"Synchronization Example\"})})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In a nutshell, our problem is due to the fact that two processes trying to access the same memory location (or variable) at the same time can result in a conflict. To ensure consistency, the processor has a set of operations named \",(0,n.jsx)(e.em,{children:\"atomic operations\"}),\" that can guarantee the linearizability of execution. That's why using \",(0,n.jsx)(e.code,{children:\"unsafe\"}),\" code with \",(0,n.jsx)(e.code,{children:\"Once\"}),\" is safe: \",(0,n.jsx)(e.code,{children:\"Once\"}),\" ensures that our operation is linear.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Also, what are atomic operations? Amdan from Stackoverflow has a rather useful \",(0,n.jsx)(e.a,{href:\"https://stackoverflow.com/a/52196874/12637\",children:\"explanation\"}),\". Basically, atomic operations are operations that don't suffer from this conflict. They are executed by the processor directly. That might help explaining some of the gibberish above in the \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\" definition above.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Okay, let's try a couple examples (actually three) and see why unsafe code can give inaccurate results or worse.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In the first example, we show how to use multi-threading by executing two threads together. This example is not related to the configuration code, so we can (and probably should) execute it in a different program.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::thread;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Executes Thread 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let thread1 = thread::spawn(|| {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        for i in 1..100 {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            println!(\"Thread 1\");\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Executes Thread 2\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let thread2 = thread::spawn(|| {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        for i in 1..100 {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            println!(\"Thread 2\");\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Makes sure our threads have executed and returned\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    thread1.join().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    thread2.join().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"Execution completed\");\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`...\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Thread 2\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Thread 2\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Thread 2\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Thread 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Thread 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Thread 1\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`...\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Thread 2\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Thread 2\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`Execution completed\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:'What our program does is launch two threads. Each thread is going to write to the terminal. Thread 1 will write \"Thread 1\" and Thread 2 will write \"Thread 2\". Since our threads are executing at the same time, we get a mix of these two lines; and it is not predictable which will happen first.'}),`\n`,(0,n.jsxs)(e.p,{children:[\"You might notice here that we are using a new weird sign \",(0,n.jsx)(e.code,{children:\"||\"}),\". That denotes a closure. A \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/rust-by-example/fn/closures.html\",children:\"closure\"}),\" is very similar to an anonymous function with the benefit that it can capture variables from its environment. There are various articles about Rust closures but, for now, if you stick to the idea that they are anonymous functions, then that's enough.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"It is important to highlight that these threads are independent from our main thread or program. While these threads start executing as soon as we spawn them, they might not finish before our program exits. So we must force them to finish execution before our program exits with the \",(0,n.jsx)(e.code,{children:\"join\"}),\" function.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now that we are comfortable running multiple threads, let's do more: Create a global variable and modify it from both threads. This might seem harmless but it is not something that Rust will allow \",(0,n.jsx)(e.em,{children:\"safely\"}),\" without jumping through hoops. So let's start with the simple and direct approach: Unsafe code. We will declare a global mutable variable, and then mutate it from inside each thread. The variable is a 32-bit integer and from inside the threads we will loop and increment this integer.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Same as before, this example can run on its own.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::thread;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub static mut INC: i32 = 0;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let thread1 = thread::spawn(|| {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        for i in 1..1000 {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            unsafe {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                INC = INC + 1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let thread2 = thread::spawn(|| {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        for i in 1..1000 {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            unsafe {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`                INC = INC + 1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    thread1.join().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    thread2.join().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    unsafe {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        println!(\"{}\", INC);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"Alright, let's execute our program. We do 999 iteration in each thread, so we expect our integer to have the value of 1998.\"}),`\n`,(0,n.jsx)(e.p,{children:\"First execution.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"code-highlight\",children:(0,n.jsx)(e.span,{className:\"code-line\",children:`1254\n`})})}),`\n`,(0,n.jsx)(e.p,{children:\"Hmm. That's not our expectation, let's try again.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"code-highlight\",children:(0,n.jsx)(e.span,{className:\"code-line\",children:`1443\n`})})}),`\n`,(0,n.jsx)(e.p,{children:\"Cool. We made a random number generator! (Slightly joking; it would be interesting to study how random these numbers are, though).\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"But why are our results not consistent? Well, it is the synchronization issue. The two threads are not synchronized and in multiple occasions (more than enough), they increment the value at the \",(0,n.jsx)(e.em,{children:\"exact\"}),\" same time. When that happens, the value is only incremented once.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"So how do we fix this problem? Well, this is exactly why the Rust team came up with the synchronization primitives.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's try to use \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\" now.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[macro_use]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`extern crate lazy_static;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::thread;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::sync::RwLock;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`lazy_static! {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub static ref INC: RwLock<i32> = RwLock::new(0);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let thread1 = thread::spawn(|| {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        for i in 1..1000 {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            let mut w = INC.write().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            *w = *w + 1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let thread2 = thread::spawn(|| {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        for i in 1..1000 {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            let mut w = INC.write().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            *w = *w + 1;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    thread1.join().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    thread2.join().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let r = INC.read().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    println!(\"{}\", *r);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"code-highlight\",children:(0,n.jsx)(e.span,{className:\"code-line\",children:`1998\n`})})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Instead of mutating the global variable directly, we are mutating our type through \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\". \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\" ensures that we are using atomic operations. If one thread is incrementing the variable, the other thread has to wait. You should have already noticed the name of \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\". It is a lock. Go again through the definition and you might understand it more stuff now. That's why in the previous \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\" example our program was stuck. It was waiting for \",(0,n.jsx)(e.code,{children:\"RwLock\"}),\" to be unlocked so that it can access it again.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Alright, let's make use of this knowledge and implement our final solution. For the fun of it, we are going to add a \",(0,n.jsx)(e.code,{children:\"String\"}),\" field. Because, you know, bureaucracy!\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[macro_use]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`extern crate lazy_static;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::ops::Deref;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // First, we get an RwLockReadGuard\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let guard = MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Next, we deref the guard and get MyConfig\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let config = guard.deref();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Freely access MyConfig by borrowing it\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(&config);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(&config.info);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // We drop the guard and unlock the RwLock\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    drop(guard);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Re-initialize our configuration\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(true), Some(String::from(\"Updated\")));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    // Go through the same process again\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let guard = MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let config = guard.deref();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(&config);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(&config.info);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    drop(guard);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::sync::RwLock;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::sync::RwLockReadGuard;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub info: String,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`lazy_static! {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub static ref CONFIG: RwLock<MyConfig> = RwLock::new(MyConfig { debug: false, info: String::from(\"Some info\") });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn init(custom_debug: Option<bool>, custom_info: Option<String>) -> Result<(), i32> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let mut w = CONFIG.write().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        match (custom_debug , custom_info) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            (Some(debug_value), Some(custom_info)) => *w = MyConfig { debug: debug_value, info: custom_info},\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            _ => (),\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Ok(())\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config() -> RwLockReadGuard<'static, MyConfig> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let m = CONFIG.read().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        m\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/main.rs:17] &config = MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    debug: false,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    info: \"Some info\",\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/main.rs:18] &config.info = \"Some info\"\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/main.rs:32] &config = MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    debug: true,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    info: \"Updated\",\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/main.rs:33] &config.info = \"Updated\"\n`})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Hooray! This works! It is a pain in the \",(0,n.jsx)(e.strong,{children:\"_ but it serves our purposes, and it is safe. That should be everything Rust stands for (At least, I'm certain of the pain in the _\"}),\" part)!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Alright, could this be simpler? We promised above to cover the \",(0,n.jsx)(e.code,{children:\"Copy\"}),\" and \",(0,n.jsx)(e.code,{children:\"Clone\"}),\" keywords, and this is the part where we do. Remember the Ownership/Borrowing concept we talked above at first? That you can't take something you don't own but you can borrow it? But what if you were able to \",(0,n.jsx)(e.em,{children:\"clone\"}),\" it. Well, that makes you able to return the actual type.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"There are types that don't \",(0,n.jsx)(e.em,{children:\"derive\"}),\" Copy. We won't go into the details of why and how. Partly because we have already covered a lot on this topic but also because there are lots of good resources on this. The Rust Programming Language book does a good job on that: \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html\",children:\"What is ownership\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's see how this would work.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`#[macro_use]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`extern crate lazy_static;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`mod config;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`use config::MyConfig;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`fn main() {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let a = MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(a);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    MyConfig::init(Some(true), Some(\"Updated\"));\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    let a = MyConfig::global_config();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    dbg!(a);\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"config.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`use std::sync::RwLock;\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`#[derive(Debug, Clone, Copy)]\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`pub struct MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub debug: bool,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub info: &'static str,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`lazy_static! {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub static ref CONFIG: RwLock<MyConfig> = RwLock::new(MyConfig { debug: false, info: \"Some info\" });\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`impl MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn init(custom_debug: Option<bool>, custom_info: Option<&'static str>) -> Result<(), i32> {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let mut w = CONFIG.write().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        match (custom_debug , custom_info) {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            (Some(debug_value), Some(custom_info)) => *w = MyConfig { debug: debug_value, info: custom_info},\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`            _ => (),\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        };\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        Ok(())\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    pub fn global_config() -> MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        let m = CONFIG.read().unwrap();\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        // This doesn't return *m but a copy of it\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`        *m\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    }\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"output\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"code-highlight\",children:[(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/main.rs:11] a = MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    debug: false,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    info: \"Some info\",\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`[src/main.rs:17] a = MyConfig {\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    debug: true,\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`    info: \"Updated\",\n`}),(0,n.jsx)(e.span,{className:\"code-line\",children:`}\n`})]})}),`\n`,(0,n.jsx)(e.p,{children:\"That's convenient but you have to keep in mind that we are returning copies of the configuration and not the actual configuration.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.p,{children:\"I hope this introduction to Rust wasn't overwhelming.\"})]});return i?(0,n.jsx)(i,Object.assign({},a,{children:c})):c}var y=b;return v;})();\n;return Component.default;","toc":[],"frontMatter":{"readingTime":{"text":"39 min read","minutes":38.615,"time":2316900,"words":7723},"slug":"rust-intro","fileName":"rust-intro.md","title":"A brief introduction to Rust","date":"2019-10-10T00:00:00.000Z","tags":["Rust","Programming"],"draft":false,"summary":"A brief introduction to Rust","images":[],"layout":"PostLayout"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.205,"time":12300,"words":41},"slug":["default"],"fileName":"default.md","name":"Abid Omar","avatar":"/static/images/avatar.png","occupation":"Entrepreneur","company":"Aderbal","email":"contact@omarabid.com","github":"https://github.com/omarabid","date":null}],"prev":{"title":"The VIM Experience","date":"2019-04-27T00:00:00.000Z","tags":["vim","productivity"],"draft":false,"summary":"7 years journey with VIM","images":[],"layout":"PostLayout","slug":"vim"},"next":{"title":"Rust 2020`:` A better ecosystem","date":"2019-11-01T00:00:00.000Z","tags":["Rust","Programming"],"draft":false,"summary":"Suggestion for Rust 2020","images":[],"layout":"PostLayout","slug":"rust-2020"}},"__N_SSG":true}
{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var c=a=>i(a,\"__esModule\",{value:!0});var y=(a,n)=>()=>(n||a((n={exports:{}}).exports,n),n.exports),N=(a,n)=>{for(var s in n)i(a,s,{get:n[s],enumerable:!0})},l=(a,n,s,t)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of m(n))!g.call(a,r)&&(s||r!==\"default\")&&i(a,r,{get:()=>n[r],enumerable:!(t=p(n,r))||t.enumerable});return a},w=(a,n)=>l(c(i(a!=null?h(u(a)):{},\"default\",!n&&a&&a.__esModule?{get:()=>a.default,enumerable:!0}:{value:a,enumerable:!0})),a),f=(a=>(n,s)=>a&&a.get(n)||(s=l(c({}),n,1),a&&a.set(n,s),s))(typeof WeakMap!=\"undefined\"?new WeakMap:0);var d=y((k,o)=>{o.exports=_jsx_runtime});var I={};N(I,{default:()=>v,frontmatter:()=>x});var e=w(d()),x={title:\"Rust as a productive high-level language\",date:\"2020-11-10\",tags:[\"Rust\",\"Programming\"],draft:!1,summary:\"High-level productivity with Rust\",images:[],layout:\"PostLayout\"};function b(a={}){let{wrapper:n}=a.components||{};return n?(0,e.jsx)(n,Object.assign({},a,{children:(0,e.jsx)(s,{})})):s();function s(){let t=Object.assign({p:\"p\",a:\"a\",hr:\"hr\",pre:\"pre\",code:\"code\",span:\"span\"},a.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(t.p,{children:[\"Rust is often critiqued as a \",(0,e.jsx)(t.a,{href:\"https://news.ycombinator.com/item?id=24536645\",children:\"not a very productive\"}),\" programming language. It is true that there is a bit of a learning curve to be able to program in Rust; but beyond that, I think it pays off in productivity; and massively I must say.\"]}),`\n`,(0,e.jsx)(t.p,{children:\"I haven't been using Rust for production much; maybe a bit more than a year. The static type checks means I'm getting much less bugs in my code, and spend considerably less time in debugging. I can safely say that, for me, Rust is more productive than JavaScript, PHP or Python and the margin keeps getting larger as I get more acquainted with the ecosystem.\"}),`\n`,(0,e.jsx)(t.hr,{}),`\n`,(0,e.jsxs)(t.p,{children:[\"To entice your interest, here is a situation that I handled lately: I have a program that writes logs to \",(0,e.jsx)(t.a,{href:\"https://en.wikipedia.org/wiki/Syslog\",children:\"syslog\"}),\" and the terminal. The program compiles and functions correctly on my development machine. However, it returned an error when I deployed it to an \",(0,e.jsx)(t.a,{href:\"https://alpinelinux.org/\",children:\"Alpine\"}),\" Docker container. Turns out, Alpine doesn't have a running syslog service by default.\"]}),`\n`,(0,e.jsxs)(t.p,{children:[\"Now that's fine, the program functioned correctly. But I don't care much for syslog on deployment since the program is running inside a container. One solution is to remove the syslog \",(0,e.jsx)(t.a,{href:\"https://en.wikipedia.org/wiki/Sink_(computing)\",children:\"drain\"}),\" but I need that for development. I can use \",(0,e.jsx)(t.a,{href:\"https://doc.rust-lang.org/reference/conditional-compilation.html\",children:\"conditional compilation\"}),\"; but there is a better option: If syslog fails, for whatever reason, just ignore that and move on.\"]}),`\n`,(0,e.jsx)(t.p,{children:\"So let's take a look at the old code.\"}),`\n`,(0,e.jsx)(t.pre,{className:\"language-rust\",children:(0,e.jsxs)(t.code,{className:\"language-rust code-highlight\",children:[(0,e.jsxs)(t.span,{className:\"code-line\",children:[(0,e.jsx)(t.span,{className:\"text-code-purple\",children:\"let\"}),\" syslog_drain \",(0,e.jsx)(t.span,{className:\"\",children:\"=\"}),\" \",(0,e.jsx)(t.span,{className:\"text-code-blue\",children:\"syslog_drain\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\"(\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\")\"}),(0,e.jsx)(t.span,{className:\"\",children:\"?\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\";\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[(0,e.jsx)(t.span,{className:\"text-code-purple\",children:\"let\"}),\" term_drain \",(0,e.jsx)(t.span,{className:\"\",children:\"=\"}),\" \",(0,e.jsx)(t.span,{className:\"text-code-blue\",children:\"term_drain\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\"(\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\")\"}),(0,e.jsx)(t.span,{className:\"\",children:\"?\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\";\"}),`\n`]})]})}),`\n`,(0,e.jsxs)(t.p,{children:[\"This code creates two logging drains: one for syslog and one for the terminal. It uses the \",(0,e.jsx)(t.a,{href:\"https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html\",children:\"? operator\"}),\" to evaluate the result. If the function returns an error, execution will stop and the error bubbles back to the top of the program.\"]}),`\n`,(0,e.jsxs)(t.p,{children:[\"I have no idea how the syslog or any particular drain fails. And honestly, I don't want to get into these details. What I want is to check if there is a failure; and if so ignore that particular drain. Or return a \",(0,e.jsx)(t.a,{href:\"https://docs.rs/slog/2.5.2/slog/struct.Discard.html\",children:\"Discard drain\"}),\".\"]}),`\n`,(0,e.jsxs)(t.p,{children:[\"The \",(0,e.jsx)(t.a,{href:\"https://doc.rust-lang.org/std/result/\",children:\"Result\"}),\" type and \",(0,e.jsx)(t.code,{children:\"? operator\"}),\" make this particularly easy. So here is the code that does that.\"]}),`\n`,(0,e.jsx)(t.pre,{className:\"language-rust\",children:(0,e.jsxs)(t.code,{className:\"language-rust code-highlight\",children:[(0,e.jsxs)(t.span,{className:\"code-line\",children:[(0,e.jsx)(t.span,{className:\"text-code-purple\",children:\"let\"}),\" syslog_drain \",(0,e.jsx)(t.span,{className:\"\",children:\"=\"}),\" \",(0,e.jsx)(t.span,{className:\"text-code-blue\",children:\"syslog_drain\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\"(\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\")\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\".\"}),(0,e.jsx)(t.span,{className:\"text-code-blue\",children:\"unwrap_or\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\"(\"}),(0,e.jsx)(t.span,{className:\"text-code-blue\",children:\"discard_drain\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\"(\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\")\"}),(0,e.jsx)(t.span,{className:\"\",children:\"?\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\")\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\";\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[(0,e.jsx)(t.span,{className:\"text-code-purple\",children:\"let\"}),\" term_drain \",(0,e.jsx)(t.span,{className:\"\",children:\"=\"}),\" \",(0,e.jsx)(t.span,{className:\"text-code-blue\",children:\"term_drain\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\"(\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\")\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\".\"}),(0,e.jsx)(t.span,{className:\"text-code-blue\",children:\"unwrap_or\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\"(\"}),(0,e.jsx)(t.span,{className:\"text-code-blue\",children:\"discard_drain\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\"(\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\")\"}),(0,e.jsx)(t.span,{className:\"\",children:\"?\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\")\"}),(0,e.jsx)(t.span,{className:\"text-code-white\",children:\";\"}),`\n`]})]})}),`\n`,(0,e.jsx)(t.p,{children:\"And that's it. This code now compiles and runs correctly. If syslog is running, it'll write logs to syslog and the terminal. Otherwise, it'll write logs to the terminal and syslog is skipped. There are no conditions, no complicated checks and it's perfectly readable.\"}),`\n`,(0,e.jsx)(t.hr,{}),`\n`,(0,e.jsx)(t.p,{children:\"There is more to Rust productivity than that. Macros, Iterators, Advanced Traits and Types, the new Async system. Once you are comfortable with all of these, you are now able to be productive, safe and fast.\"})]})}}var v=b;return f(I);})();\n;return Component;","toc":[],"frontMatter":{"readingTime":{"text":"3 min read","minutes":2.43,"time":145800,"words":486},"slug":"rust-high-level-language","fileName":"rust-high-level-language.md","title":"Rust as a productive high-level language","date":"2020-11-10T00:00:00.000Z","tags":["Rust","Programming"],"draft":false,"summary":"High-level productivity with Rust","images":[],"layout":"PostLayout"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.215,"time":12900,"words":43},"slug":["default"],"fileName":"default.md","name":"Abid Omar","avatar":"/static/images/avatar.png","occupation":"Entrepreneur","company":"Aderbal","email":"contact@omarabid.com","github":"https://github.com/omarabid","date":null}],"prev":{"title":"How complex is modern web development","date":"2020-10-26T00:00:00.000Z","tags":["Web","Programming"],"draft":false,"summary":"Visualizing the complexity of modern web development","images":[],"layout":"PostLayout","slug":"modern-web-dev"},"next":{"title":"Regulation as a Service","date":"2021-02-01T00:00:00.000Z","tags":["Business"],"draft":false,"summary":"Can you sell regulation?","images":[],"layout":"PostLayout","slug":"regulation-as-a-service"}},"__N_SSG":true}
{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of f(e))!m.call(t,i)&&i!==r&&o(t,i,{get:()=>e[i],enumerable:!(s=u(e,i))||s.enumerable});return t};var w=(t,e,r)=>(r=t!=null?d(p(t)):{},a(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),b=t=>a(o({},\"__esModule\",{value:!0}),t);var c=g((R,l)=>{l.exports=_jsx_runtime});var _={};y(_,{default:()=>T,frontmatter:()=>k});var n=w(c()),k={title:\"A primer to Rust Async\",date:\"2020-02-10\",tags:[\"Rust\",\"Async\",\"Programming\"],draft:!1,summary:\"An introduction to Rust Async programming\",images:[],layout:\"PostLayout\"};function h(t){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",em:\"em\",h3:\"h3\",pre:\"pre\",blockquote:\"blockquote\",strong:\"strong\",ul:\"ul\",li:\"li\",h4:\"h4\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This article is not comprehensive on the Rust Async topic but could be an easy overview if you have no idea about \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)\",children:\"Async Programming\"}),\" in Rust or in general. If you are wondering about the new \",(0,n.jsx)(e.code,{children:\"async/await\"}),\" keywords, Futures, and intrigued what \",(0,n.jsx)(e.a,{href:\"https://tokio.rs\",children:\"Tokio\"}),\" is useful for, then you should feel less clueless by the end.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Rust Async is the \",(0,n.jsx)(e.a,{href:\"https://blog.rust-lang.org/2019/11/07/Async-await-stable.html\",children:\"new hot thing\"}),\" in Rust's land. It has been hailed as a big milestone for Rust; especially for people developing highly performant networking applications. The long time for development, the different incompatible versions, and the various libraries; however, might made it \",(0,n.jsx)(e.em,{children:\"not\"}),\" very straightforward to grasp. There is a lot going and it's not obvious from where to start.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's start from the beginning.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"What is Async?\"}),`\n`,(0,n.jsx)(e.p,{children:\"There are several articles, books and videos that goes in depth on Async; but I'll give you the short version: If you have a single processor and want to execute two tasks simultaneously (kind of), how would you do it? The solution is to run a little bit of the first task, then switch and run a little bit of the second task, then switch back, etc... until both tasks are complete.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is useful if you want to give the impression that the computer is running both tasks simultaneously and the computer is fast enough to trick the human eye (i.e.: multitasking). Another useful use-case is \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Input/output\",children:\"IO\"}),\" operations. When your program is waiting for a network response, your CPU is sitting idle. This is an ideal time to switch to another task.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"So how do we write Async code?\"}),`\n`,(0,n.jsx)(e.p,{children:\"First, let's start with some synchronous code.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Synchronous code\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's make a simple program that reads two files: \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\" and \",(0,n.jsx)(e.code,{children:\"file2.txt\"}),\". We start with \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\" and then move to \",(0,n.jsx)(e.code,{children:\"file2.txt\"}),\", in that order.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We split the program into two files: \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\" and \",(0,n.jsx)(e.code,{children:\"file.rs\"}),\". \",(0,n.jsx)(e.code,{children:\"file.rs\"}),\" has a single function: \",(0,n.jsx)(e.code,{children:\"read_file\"}),\", and in \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\" we call this function with the path of each file. You can find the code below.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"file.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use std::fs::File;\nuse std::io::{self, Read};\n\npub fn read_file(path: &str) -> io::Result<String> {\n    let mut file = File::open(path)?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer)?;\n    Ok(buffer)\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use std::io;\n\nmod file;\n\nfn main() -> io::Result<()> {\n    println!(\"program started\");\n\n    let file1 = file::read_file(\"src/file1.txt\")?;\n    println!(\"processed file 1\");\n\n    let file2 = file::read_file(\"src/file2.txt\")?;\n    println!(\"processed file 2\");\n\n    dbg!(&file1);\n    dbg!(&file2);\n\n    Ok(())\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Use \",(0,n.jsx)(e.code,{children:\"cargo run\"}),\" to compile and run the program. The program should run with no surprises but make sure you have placed two files (\",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\" and \",(0,n.jsx)(e.code,{children:\"file2.txt\"}),\") in your \",(0,n.jsx)(e.code,{children:\"src\"}),\" folder.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-shell\",children:`program started\nprocessed file 1\nprocessed file 2\n[src/main.rs:14] &file1 = \"file 1\\\\n\"\n[src/main.rs:15] &file2 = \"file 2\\\\n\"\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"So far, all is good. If you need \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\" processed before \",(0,n.jsx)(e.code,{children:\"file2.txt\"}),\", then this is the only way to go. But there are other times when you don't care of the order each file is processed. Ideally, you would be looking to have the files processed as fast as possible.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In that case, we can make use of multi-threading.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"The multi-threading approach\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"For this, we run a separate thread for each function call. Since we are using multi-threaded code, and if we want to access the file contents outside the threads, we have to use one of the \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/\",children:\"sync primitives\"}),\" that Rust provides.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here is how it will affect the code: \",(0,n.jsx)(e.code,{children:\"file.rs\"}),\" will stay the same, so that's one thing already taken care of. In \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\", we need to initialize two \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/struct.RwLock.html\",children:\"RwLock\"}),\"s; these will be used later in the threads to store the file contents.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Then, we run an infinite loop where we try to read the content of these two variables. If these variables are not empty, then we know that the file processing (or reading) completed. (This means that the files shouldn't be empty; otherwise our program will just keep, mistakenly, waiting. An alternative is to use \",(0,n.jsx)(e.code,{children:\"Option<String>\"}),\" and check if the \",(0,n.jsx)(e.code,{children:\"Option\"}),\" in \",(0,n.jsx)(e.code,{children:\"None\"}),\").\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you need more overview about RwLock and multi-threading, you can check my previous article: \",(0,n.jsx)(e.a,{href:\"https://omarabid.com/rust-intro\",children:\"A brief introduction to Rust\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"This code requires the \",(0,n.jsx)(e.a,{href:\"https://crates.io/crates/lazy_static\",children:\"lazy_static\"}),\" crate.\"]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use std::io;\nuse std::sync::RwLock;\nuse std::thread;\n\nuse lazy_static::lazy_static;\n\nmod file;\n\n// A sync primitive that allows to read/write from variables between threads.\n// we declare the variables here, this requires the lazy_static crate\nlazy_static! {\n    static ref FILE1: RwLock<String> = RwLock::new(String::from(\"\"));\n    static ref FILE2: RwLock<String> = RwLock::new(String::from(\"\"));\n}\n\nfn main() -> io::Result<()> {\n    println!(\"program started\");\n\n    let thread_1 = thread::spawn(|| {\n        let mut w1 = FILE1.write().unwrap();\n        *w1 = file::read_file(\"src/file1.txt\").unwrap();\n        println!(\"read file 1\");\n    });\n\n    println!(\"Launched Thread 1\");\n\n    let thread_2 = thread::spawn(|| {\n        let mut w2 = FILE2.write().unwrap();\n        *w2 = file::read_file(\"src/file2.txt\").unwrap();\n        println!(\"read file 2\");\n    });\n\n    println!(\"Launched Thread 2\");\n\n    let mut rf1: bool = false;\n    let mut rf2: bool = false;\n\n    loop {\n        let r1 = FILE1.read().unwrap();\n        let r2 = FILE2.read().unwrap();\n\n        if *r1 != String::from(\"\") && rf1 == false {\n            println!(\"completed file 1\");\n            rf1 = true;\n        }\n\n        if *r2 != String::from(\"\") && rf2 == false {\n            println!(\"completed file 2\");\n            rf2 = true;\n        }\n    }\n\n    Ok(())\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Interestingly, if we have a very large \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\", we get a strange output. The second file is processed first (\",(0,n.jsx)(e.em,{children:\"read file 2\"}),\"); but inside our loop, the program seems to block and wait for the first file.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-shell\",children:`program started\nLaunched Thread 1\nLaunched Thread 2\nread file 2\nread file 1\ncompleted file 1\ncompleted file 2\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Multi-threading can be a bit tricky because we have to account for the \",(0,n.jsx)(e.a,{href:\"https://stackoverflow.com/questions/52196678/what-are-atomic-operations-for-newbies\",children:\"atomic operations\"}),\" which can be \",(0,n.jsx)(e.em,{children:\"blocking\"}),\". We used the \",(0,n.jsx)(e.code,{children:\"read\"}),\" function to unlock our variable, and the \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/sync/struct.RwLock.html\",children:\"documentation\"}),\" warns about this behavior.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Locks this rwlock with shared read access, blocking the current thread until it can be acquired.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Luckily, there is a \",(0,n.jsx)(e.code,{children:\"try_read\"}),\" function which returns an \",(0,n.jsx)(e.code,{children:\"Err\"}),\" if the lock can't be acquired.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Attempts to acquire this rwlock with shared read access.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"If the access could not be granted at this time, then \",(0,n.jsx)(e.code,{children:\"Err\"}),\" is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this second attempt, we use \",(0,n.jsx)(e.code,{children:\"try_read\"}),\" and ignore the \",(0,n.jsx)(e.code,{children:\"Err\"}),\"s returned since they should mean our lock is busy. This helps moving our program to the next variable, and handles the one which gets ready first.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use std::io;\nuse std::sync::RwLock;\nuse std::thread;\n\nuse lazy_static::lazy_static;\n\nmod file;\n\nlazy_static! {\n    static ref FILE1: RwLock<String> = RwLock::new(String::from(\"\"));\n    static ref FILE2: RwLock<String> = RwLock::new(String::from(\"\"));\n}\n\nfn main() -> io::Result<()> {\n    println!(\"program started\");\n\n    let thread_1 = thread::spawn(|| {\n        let mut w1 = FILE1.write().unwrap();\n        *w1 = file::read_file(\"src/file1.txt\").unwrap();\n        println!(\"read file 1\");\n    });\n\n    println!(\"Launched Thread 1\");\n\n    let thread_2 = thread::spawn(|| {\n        let mut w2 = FILE2.write().unwrap();\n        *w2 = file::read_file(\"src/file2.txt\").unwrap();\n        println!(\"read file 2\");\n    });\n\n    println!(\"Launched Thread 2\");\n\n    let mut rf1: bool = false;\n    let mut rf2: bool = false;\n\n    loop {\n        let r1 = FILE1.try_read();\n        let r2 = FILE2.try_read();\n\n        match r1 {\n            Ok(v) => {\n                if *v != String::from(\"\") && rf1 == false {\n                    println!(\"completed file 1\");\n                    rf1 = true;\n                }\n            }\n            // If rwlock can't be acquired, ignore the error\n            Err(_) => {}\n        }\n\n        match r2 {\n            Ok(v) => {\n                if *v != String::from(\"\") && rf2 == false {\n                    println!(\"completed file 2\");\n                    rf2 = true;\n                }\n            }\n            // If rwlock can't be acquired, ignore the error\n            Err(_) => {}\n        }\n    }\n\n    Ok(())\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Now the execution is different. If \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\" is much bigger than \",(0,n.jsx)(e.code,{children:\"file2.txt\"}),\", then the second file should be processed first.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-shell\",children:`program started\nLaunched Thread 1\nLaunched Thread 2\nread file 2\ncompleted file 2\nread file 1\ncompleted file 1\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"The limits of multi-threading\"}),`\n`,(0,n.jsx)(e.p,{children:\"Why do we need Async if we already have multi-threading? There are two main advantages: performance and simplicity. Spawning threads is expensive; and as you can conclude from the above, writing multi-threaded code can get quite complicated.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This answer on \",(0,n.jsx)(e.a,{href:\"https://stackoverflow.com/a/42861328/12637\",children:\"stackoverflow\"}),\" touches up on these points.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"Why is async considered better performing than multi-threading?\"})}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"When your code CPU-bound, there will be a little difference between between Tasks + async/await and pure multi-threaded code. In IO bound code, multi threading is the worst throughput you can have. Tasks + async/await will blow away any IO-bound-threadpool you can write your own. threads don't scale. usually (especially on Server side) you have both. you read some data from a connection (IO), then continue processing it on the CPU (json parsing, calculations etc.) and write the result back to the connection (IO again). Tasks + async/await are faster in this case than a pure multi threaded code.\"}),`\n`,(0,n.jsx)(e.p,{children:`It's the simplicity which makes async/await so appealing. writing a synchronous code which is actually asynchronous. if this is not \"high level programing\", what is?`}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"And that's where Rust Async comes in. Here is a quote for Aaron Turon from \",(0,n.jsx)(e.a,{href:\"https://aturon.github.io/blog/2016/08/11/futures/\",children:\"Zero-cost futures in Rust\"}),\" .\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"We\\u2019ve wanted something higher level, with better ergonomics, but also better composability, supporting an ecosystem of asynchronous abstractions that all work together. This story might sound familiar: it\\u2019s the same goal that\\u2019s led to the introduction of futures (aka promises) in many languages, with some supporting async/await sugar on top.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Async, the keywords\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Rust focus is to make writing Async code as simple as it can get. You only need to add the \",(0,n.jsx)(e.code,{children:\"async/await\"}),\" keywords to make your code Async: \",(0,n.jsx)(e.code,{children:\"async\"}),\" before the function declaration and \",(0,n.jsx)(e.code,{children:\"await\"}),\" to resolve your \",(0,n.jsx)(e.code,{children:\"async\"}),\" functions.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"That sounds great. Let's give it a try.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"file.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use std::fs::File;\nuse std::io::{self, Read};\n\npub async fn read_file(path: &str) -> io::Result<String> {\n    let mut file = File::open(path)?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer)?;\n    Ok(buffer)\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use std::io;\n\nmod file;\n\nfn main() -> io::Result<()> {\n    let r1 = file::read_file(\"src/file1.txt\");\n    let r2 = file::read_file(\"src/file2.txt\");\n\n    let f1 = r1.await;\n    let f2 = r2.await;\n\n    dbg!(f1);\n    dbg!(f2);\n\n    Ok(())\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This doesn't work, however. \",(0,n.jsx)(e.code,{children:\"await\"}),\" is available only inside an \",(0,n.jsx)(e.code,{children:\"async\"}),\" block or function. If we try to run this code, the compiler will throw this error.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-shell\",children:\"error[E0728]: `await` is only allowed inside `async` functions and blocks\\n --> src/main.rs:9:14\\n  |\\n5 | fn main() -> io::Result<()> {\\n  |    ---- this is not `async`\\n...\\n9 |     let f1 = r1.await;\\n  |              ^^^^^^^^ only allowed inside `async` functions and blocks\\n\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Can we make the \",(0,n.jsx)(e.code,{children:\"main\"}),\" function async? Unfortunately, it's not that simple; we get another error.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-shell\",children:\"error[E0277]: `main` has invalid return type `impl std::future::Future`\\n --> src/main.rs:5:20\\n  |\\n5 | async fn main() -> io::Result<()> {\\n  |                    ^^^^^^^^^^^^^^ `main` can only return types that implement `std::process::Termination`\\n  |\\n  = help: consider using `()`, or a `Result`\\n\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The error message is a bit intriguing, though. It seems that the \",(0,n.jsx)(e.code,{children:\"async\"}),\" keyword makes our function return a \",(0,n.jsx)(e.code,{children:\"Future\"}),\" instead of the declared type.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here is some excerpt from the \",(0,n.jsx)(e.a,{href:\"https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md\",children:\"async-await RFC\"}),\".\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:'The return type of an async function is a unique anonymous type generated by the compiler, similar to the type of a closure. You can think of this type as being like an enum, with one variant for every \"yield point\" of the function - the beginning of it, the await expressions, and every return. Each variant stores the state that is needed to be stored to resume control from that yield point.'}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The return type of an async function is a \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/future/trait.Future.html\",children:\"Future\"}),\" (precisely, a closure that implements the Future trait).\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"The anonymous return type implements Future, with the return type as its Item.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"What about \",(0,n.jsx)(e.code,{children:\"await\"}),\"? From the same RFC.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"The await! builtin expands roughly to this:\"}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`let mut future = IntoFuture::into_future($expression);\nlet mut pin = unsafe { Pin::new_unchecked(&mut future) };\nloop {\n    match Future::poll(Pin::borrow(&mut pin), &mut ctx) {\n          Poll::Ready(item) => break item,\n          Poll::Pending     => yield,\n    }\n}\n`})}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"This is not a literal expansion, because the yield concept cannot be expressed in the surface syntax within async functions. This is why await! is a compiler builtin instead of an actual macro.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"So roughly speaking: \",(0,n.jsx)(e.code,{children:\"async\"}),\" makes our function a \",(0,n.jsx)(e.code,{children:\"Future\"}),\". \",(0,n.jsx)(e.code,{children:\"await\"}),\" loops through that future until completion. However, there is another missing piece of the puzzle: Rust doesn't resolve the future on its own. We need an executor that is going to run this Async code.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"What is an executor?\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you rewind to our multi-threading example, you'll notice that we used a \",(0,n.jsx)(e.code,{children:\"loop\"}),\" in order to detect when our files were processed. It was simple: Loop infinitely until there is some content in the variable and then do something. We could have improved on that by breaking out of the loop if both files are read.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"An Async executor is the loop. Rust, by default, doesn't have any built-in executors. There is a number of Async run-times; \",(0,n.jsx)(e.a,{href:\"https://async.rs/\",children:\"async-std\"}),\" and \",(0,n.jsx)(e.a,{href:\"https://tokio.rs/\",children:\"Tokio\"}),\" being the most popular ones. The job of a run-time is to poll your async functions (\",(0,n.jsx)(e.code,{children:\"Future\"}),\"s) until they finally return a value.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This \",(0,n.jsx)(e.a,{href:\"https://www.reddit.com/r/rust/comments/d1obg6/with_asyncawait_i_dont_get_what_runs_the_await/ezoxzjn/\",children:\"discussion\"}),\" on Reddit has more details, but you can ignore the specifics for now.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Creating/Composing a future object (for example, by calling an async function which calls another async function) does not involve any progress. Only when you pass it to something that actively polls it, the future object starts its work and makes progress (poll by poll). At that point, we refer to the whole future thingy as a task. A suspension point simply makes a call to the future's poll method return immediately with a Poll::Pending value if the value is not ready yet.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"A simple executor\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.a,{href:\"https://crates.io/crates/futures\",children:\"futures\"}),\" crate has a very basic executor, and a function to join two \",(0,n.jsx)(e.code,{children:\"Future\"}),\"s. Let's give it a shot.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"The following code uses the \",(0,n.jsx)(e.a,{href:\"https://crates.io/crates/futures\",children:\"futures\"}),\" crate version 0.3.4\"]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use futures::executor::block_on;\nuse futures::join;\nuse std::io;\n\nmod file;\n\nfn main() -> io::Result<()> {\n\n    println!(\"Program started\");\n\n    // Block on the final future\n    block_on(load_files());\n\n    Ok(())\n}\n\nasync fn load_files() {\n    // Join the two futures together\n    join!(load_file_1(), load_file_2());\n}\n\nasync fn load_file_1() {\n    let r1 = file::read_file(\"src/file1.txt\").await;\n    println!(\"file 1 size: {}\", r1.unwrap().len());\n}\n\nasync fn load_file_2() {\n    let r2 = file::read_file(\"src/file2.txt\").await;\n    println!(\"file 2 size: {}\", r2.unwrap().len());\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"To verify the asynchronicity, I dumped a bunch of data in \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\". Rust is pretty fast; at the time of testing this, \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\" had over 5Gb of text.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-shell\",children:`Program started\nfile 1 size: 5430447414\nfile 2 size: 7\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Unfortunately, this looks like (and it is) blocking on the first file function, again.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"So what is Async anyway?\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Similar to multi-threading, there are some gotchas and things to worry about in Async programming. The truth is, the \",(0,n.jsx)(e.code,{children:\"async\"}),\" keyword doesn't magically make your code async; it just makes your function return a \",(0,n.jsx)(e.code,{children:\"Future\"}),\". You still have to do the heavy lifting of \",(0,n.jsx)(e.em,{children:\"scheduling\"}),\" your code execution.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This means that your function has to return quickly that it's not ready instead of being stuck doing calculations. In our case, the clogging is happening specifically at \",(0,n.jsx)(e.code,{children:\"File::Open\"}),\" and \",(0,n.jsx)(e.code,{children:\"file.read_to_string\"}),\". These two functions are not \",(0,n.jsx)(e.code,{children:\"async\"}),\" and therefore block execution.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We need to create an Async version of these two functions. Luckily, some handsome people over \",(0,n.jsx)(e.a,{href:\"https://async.rs/\",children:\"async-std\"}),\" did the hard work of rewriting the std library in Rust to an async version.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"This crate provides an async version of std. It provides all the interfaces you are used to, but in an async version and ready for Rust's async/await syntax.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"File IO with async-std\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The only change we have to make is to replace our \",(0,n.jsx)(e.code,{children:\"std\"}),\" imports with \",(0,n.jsx)(e.code,{children:\"async_std\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"For the following example, we are using the \",(0,n.jsx)(e.a,{href:\"https://crates.io/crates/async-std/1.5.0\",children:\"async-std\"}),\" crate version 1.5.0\"]})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"file.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`// We use async_std instead of std, it's that simple.\nuse async_std::io;\nuse async_std::fs::File;\nuse async_std::prelude::*;\n\npub async fn read_file(path: &str) -> io::Result<String> {\n    let mut file = File::open(path).await?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer).await?;\n    Ok(buffer)\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The code in \",(0,n.jsx)(e.code,{children:\"main.rs\"}),\" remains the same; the program is still using the \",(0,n.jsx)(e.code,{children:\"block_on\"}),\" executor from the \",(0,n.jsx)(e.code,{children:\"futures\"}),\" crates.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Compile and run the program. (make sure to have a fat \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\")\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-shell\",children:`Program started\nfile 2 size: 7\nfile 1 size: 5430447414\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Finally! \",(0,n.jsx)(e.code,{children:\"file2.txt\"}),\" gets processed first and fast here, then the program moves to \",(0,n.jsx)(e.code,{children:\"file1.txt\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Manually implementing Async with Futures\"}),`\n`,(0,n.jsx)(e.p,{children:\"Let's recap what we learned so far:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"async\"}),\" makes our function return a \",(0,n.jsx)(e.code,{children:\"Future\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Running our \",(0,n.jsx)(e.code,{children:\"Future\"}),\" requires a run-time.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The run-time checks if our \",(0,n.jsx)(e.code,{children:\"Future\"}),\" is ready; and when ready returns its value.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"One more thing to add: Rust futures are \",(0,n.jsx)(e.em,{children:\"lazy\"}),\". The executor doesn't constantly \",(0,n.jsx)(e.em,{children:\"poll\"}),\" the \",(0,n.jsx)(e.code,{children:\"Future\"}),\" but instead waits for the \",(0,n.jsx)(e.code,{children:\"Future\"}),\" to signal that it is due for a poll.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The future we will design is rather useless but could demonstrate how progress is made during execution. The future object holds some state (an \",(0,n.jsx)(e.code,{children:\"i32\"}),\" field named \",(0,n.jsx)(e.code,{children:\"counter\"}),\"). At each \",(0,n.jsx)(e.code,{children:\"poll\"}),\", we increment our \",(0,n.jsx)(e.code,{children:\"counter\"}),\" by one, and then schedule another \",(0,n.jsx)(e.code,{children:\"poll\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"To demonstrate task switching, we'll create two different Future types. Their functionality is identical, though.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"main.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use futures::executor::block_on;\nuse futures::join;\n\nmod asyncop;\n\nuse asyncop::{Task1, Task2};\n\nfn main() {\n    // Wait for the joined future completion\n    block_on(asyncop());\n}\n\nasync fn asyncop() {\n    // Join the two futures\n    join!(fut1(), fut2());\n}\n\n// Future 1\nfn fut1() -> Task1 {\n    Task1 { count: 0 }\n}\n\n// Future 2\nfn fut2() -> Task2 {\n    Task2 { count: 0 }\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"asyncop.rs\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use std::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\n#[derive(Debug)]\npub struct Task1 {\n    pub count: i32,\n}\n\nimpl Future for Task1 {\n    type Output = ();\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // If counter reaches 99, our future is ready\n        if &self.count > &100 {\n            Poll::Ready(())\n        } else {\n            println!(\"Task 1 Progress - {}\", &self.count);\n\n            // Increment counter\n            self.get_mut().count += 1;\n            // Schedule future for another poll()\n            cx.waker().clone().wake();\n\n            Poll::Pending\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct Task2 {\n    pub count: i32,\n}\n\nimpl Future for Task2 {\n    type Output = ();\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // If counter reaches 99, our future is ready\n        if &self.count > &100 {\n            Poll::Ready(())\n        } else {\n            println!(\"Task 2 Progress - {}\", &self.count);\n\n            // Increment counter\n            self.get_mut().count += 1;\n            // Schedule future for another poll()\n            cx.waker().clone().wake();\n\n            Poll::Pending\n        }\n    }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The output on execution demonstrates how the executor is switching between \",(0,n.jsx)(e.em,{children:\"Future 1\"}),\" and \",(0,n.jsx)(e.em,{children:\"Future 2\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-shell\",children:`...\nTask 1 Progress - 95\nTask 2 Progress - 95\nTask 1 Progress - 96\nTask 2 Progress - 96\nTask 1 Progress - 97\nTask 2 Progress - 97\nTask 1 Progress - 98\nTask 2 Progress - 98\nTask 1 Progress - 99\nTask 2 Progress - 99\nTask 1 Progress - 100\nTask 2 Progress - 100\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Wrap-up\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this post we covered synchronous code, multi-threaded code, some Async terminology in Rust, the async-std library and a simple \",(0,n.jsx)(e.code,{children:\"Future\"}),\" implementation. This is, really, a lightweight introduction and many of the specifics were omitted for brevity.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"I've compiled a list of resources below if you want to explore more.\"}),`\n`,(0,n.jsx)(e.h4,{children:\"Further resources on Async Rust\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://rust-lang.github.io/async-book/\",children:\"Asynchronous Programming in Rust\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://cfsamson.github.io/book-exploring-async-basics/introduction.html\",children:\"The Node Experiment - Exploring Async Basics with Rust\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/\",children:\"Green threads explained in 200 lines of Rust\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.viget.com/articles/understanding-futures-in-rust-part-1/\",children:\"Understanding Futures In Rust -- Part 1\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.viget.com/articles/understanding-futures-is-rust-part-2/\",children:\"Understanding Futures In Rust -- Part 2\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://dev.to/iam_aprogrammer/pinning-asynchronous-programming-in-rust-why-what-and-how-3eal\",children:\"Pinning - Asynchronous Programming in Rust: Why, What, and How\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://tmandry.gitlab.io/blog/posts/optimizing-await-1/\",children:\"How Rust optimizes async/await I\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://tmandry.gitlab.io/blog/posts/optimizing-await-2/\",children:\"How Rust optimizes async/await II: Program analysis\"})}),`\n`]})]})}function v(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var T=v;return b(_);})();\n;return Component;","toc":[],"frontMatter":{"readingTime":{"text":"17 min read","minutes":16.07,"time":964200,"words":3214},"slug":"async-rust","fileName":"async-rust.md","title":"A primer to Rust Async","date":"2020-02-10T00:00:00.000Z","tags":["Rust","Async","Programming"],"draft":false,"summary":"An introduction to Rust Async programming","images":[],"layout":"PostLayout"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.205,"time":12300,"words":41},"slug":["default"],"fileName":"default.md","name":"Abid Omar","avatar":"/static/images/avatar.png","occupation":"Entrepreneur","company":"Aderbal","email":"contact@omarabid.com","github":"https://github.com/omarabid","date":null}],"prev":{"title":"The modern web is becoming an unusable, user-hostile wasteland","date":"2019-12-20T00:00:00.000Z","tags":["Web","Programming"],"draft":false,"summary":"Some thoughts about the modern web","images":[],"layout":"PostLayout","slug":"the-modern-web"},"next":{"title":"Examining the complex web of USD stable coins","date":"2020-06-05T00:00:00.000Z","tags":["Crypto","Defi"],"draft":false,"summary":"A brief look on some USD stable coins","images":[],"layout":"PostLayout","slug":"usd-stable-coins"}},"__N_SSG":true}